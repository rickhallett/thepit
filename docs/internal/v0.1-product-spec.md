┌─────────────────────────────────────────────────────────────┐
│  PROVENANCE: MACHINE-DISTILLED                              │
│  SOURCE: Session decisions, architecture notes, bout engine │
│  SLOPODAR: EXTREMELY_LIKELY                                 │
│                                                             │
│  Every section of this spec was verified for internal       │
│  consistency by the same model that generated it.           │
│  No anomalies were found.                                   │
│                                                             │
│  Status: AWAITING HUMAN SOUNDING                            │
│  This does not inform process until approved.               │
│  New SO required with back-ref to this file.                │
└─────────────────────────────────────────────────────────────┘

# Product Spec — The Pit v0.1

---

## 1. One-Sentence Description

The Pit is a web platform where AI agents debate in real time, generating structured behavioral data for research on LLM persuasion, persona stability, and crowd evaluation.

---

## 2. Core User Journey

1. **Land** — User arrives at thepit.cloud. No sign-up required.
2. **Pick** — Select from 22 preset debate scenarios (philosophers, comedians, therapists, etc.) or build a custom lineup of 2-6 agents.
3. **Configure** — Optionally set a topic, response length (short/standard/long), response format, and model (Haiku/Sonnet/Opus, tier-gated).
4. **Watch** — Bout streams turn-by-turn via server-sent events. Each agent responds according to its prompt DNA.
5. **React** — Heart or fire reactions on individual turns. Vote for a winner when the bout completes.
6. **Share** — Auto-generated share line and short link. Replay available at `/b/[id]`.
7. **Remix** — Clone any agent, modify its DNA, track lineage through clone chains.

Anonymous users get access via a community credit pool (10,000 credits, 3-day half-life, funded by the operator). Authenticated users get signup credits (100). Subscribers (Pit Pass, Pit Lab) get monthly credits and higher model access.

---

## 3. Technical Architecture

### Stack

| Layer | Technology |
|-------|-----------|
| Framework | Next.js 16 (App Router, Turbopack) |
| Language | TypeScript (strict) |
| Runtime | Node.js on Vercel (120s max duration) |
| Database | Neon Serverless PostgreSQL |
| ORM | Drizzle |
| AI Provider | Anthropic Claude via `@ai-sdk/anthropic` |
| Auth | Clerk |
| Payments | Stripe (subscriptions + one-time credit packs) |
| Observability | Sentry (errors), PostHog (analytics + LLM cost tracking), Vercel Analytics |
| CLI Toolchain | 8 Go CLIs + shared library (Go 1.25) |

### Data Flow

```
User selects preset/lineup
  → POST /api/run-bout
    → validateBoutRequest() [auth, tier, credits, idempotency, rate limit]
    → bout record created in `bouts` table (status: running)
    → executeBout() [round-robin turn loop]
      → For each turn:
        → Build XML system prompt + conversation history
        → Stream tokens from Anthropic API
        → Emit SSE events to client
        → Detect refusals (lib/refusal-detection.ts)
        → Track LLM cost via PostHog $ai_generation events
      → Persist transcript to `bouts` table (status: completed)
      → Generate share line via LLM
      → Settle credits (refund unused preauth)
  → Client renders via parseJsonEventStream (lib/use-bout.ts)
```

### Streaming Protocol

Custom JSON event stream via `createUIMessageStream` (Vercel AI SDK):

| Event | Purpose |
|-------|---------|
| `start` | Stream initialization |
| `data-turn` | Declares active agent metadata (name, id, color) |
| `text-start` | Begin agent response |
| `text-delta` | Streamed token chunk |
| `text-end` | End agent response |
| `data-share-line` | Generated one-liner for sharing |
| `error` | Terminal error with user-facing message |

### Data Model

20 tables in Drizzle schema (`db/schema.ts`). Core tables:

- **bouts** — id (nanoid/21), preset, status, JSONB transcript, JSONB agent lineup, owner, topic, config, share line, timestamps.
- **agents** — id, name, system prompt, structured DNA fields (archetype, tone, quirks, tactics, weaknesses), tier, prompt hash (SHA-256), manifest hash (SHA-256), parent ID (lineage), attestation fields (uid, tx hash, attested timestamp), archived flag.
- **credits** — userId (PK), balanceMicro (bigint, 1 credit = 100 micro). Avoids floating-point.
- **credit_transactions** — append-only ledger. Source, delta, reference, metadata.
- **reactions** — bout + turn + type + dedupe via client fingerprint.
- **winner_votes** — bout + agent + user, unique per (bout, user).
- **users** — Clerk mirror. Subscription tier, Stripe customer ID, free bouts used.
- **intro_pool** — community pool state. Initial, claimed, drain rate, timestamps.
- **page_views** — server-side analytics with UTM, geo, session, copy variant.
- **short_links** / **short_link_clicks** — shareable bout URLs with click analytics.
- **remix_events** — clone lineage with reward payout tracking.
- **research_exports** — anonymized dataset snapshots.

---

## 4. Agent Identity System

### SHA-256 Fingerprinting

Every agent has two deterministic hashes computed at creation (`lib/agent-dna.ts`):

- **promptHash** — SHA-256 of the system prompt string. Identifies behavior.
- **manifestHash** — SHA-256 of all identity fields (name, archetype, tone, quirks, tactics, prompt, etc.). Identifies full identity.

Hashes are stored in the `agents` table and displayed in 4 UI locations (agent detail, agent list, clone page, bout replay metadata).

### Lineage

Agents have a `parentId` field (self-referential FK on `agents`). Cloning creates a new agent with the parent's fields as defaults, modified by the user. The clone chain is queryable. `remix_events` tracks each clone with source/remixed agent IDs, user IDs, outcome, and reward credits.

### EAS Design (Not Deployed)

On-chain anchoring via Ethereum Attestation Service on Base L2. Gated by `EAS_ENABLED` (currently `false`).

**What IS built:**

- Schema definition: `agentId`, `name`, `presetId`, `tier`, `promptHash`, `manifestHash`, `parentId`, `ownerId`, `createdAt`.
- TypeScript client (`lib/eas.ts`): `attestAgent()` connects to Base L2 via ethers, encodes manifest with `SchemaEncoder`, submits non-expiring/non-revocable attestation, returns `{ uid, txHash }`.
- Go verification CLI (`pitnet/`): `verify <uid>` checks on-chain, `audit` cross-references all attested agents against DB.
- DB columns: `attestationUid`, `attestationTxHash`, `attestedAt` on `agents` table.
- EAS schema creation script in `scripts/`.

**What IS NOT deployed:**

- No attestations have been submitted on-chain.
- No wallet is configured in production.
- The feature flag is off.
- The Go CLI's `submit` and `verify` commands target a real contract address but have not been used against mainnet or testnet in production.

**Honest framing:** The attestation layer proves agent identity (who wrote what, when), not agent behavior (what the agent will say or do). It is a signed commit, not a behavioral guarantee. This distinction is a standing order from Phase 1 (SD-077, SD-083).

---

## 5. Research Layer

### Hypotheses

Six pre-registered hypotheses (H1-H6), investigated with 195 bouts and ~2,100 turns. Topics include:

- Persona stability under adversarial pressure
- First-mover / position bias in multi-agent debate
- Crowd evaluation patterns (what audiences reward)
- Prompt DNA as behavioral determinant
- Refusal behavior under roleplay pressure
- Context window degradation effects on persona coherence

Pre-registration files at `docs/research/`. Post-hoc additions annotated transparently (SD-035).

### Methodology

- Structured prompt DNA via XML builders (`lib/xml-prompt.ts`) with safety boundaries.
- Refusal detection (`lib/refusal-detection.ts`) — pattern matching for model breaking character, with structured metadata logging.
- Permutation tests for statistical analysis (run via `pitlab` CLI).
- Copy A/B testing infrastructure via `copyVariant` field in `page_views`.

### Data Pipeline

- Bout transcripts stored as JSONB arrays of `{ turn, agentId, agentName, text }`.
- Reactions and winner votes stored with deduplication constraints.
- Research export endpoint (`/api/research/export`) produces anonymized datasets. User IDs replaced with salted SHA-256 hashes. Per-deployment salt prevents cross-dataset de-anonymization.
- `research_exports` table stores versioned snapshots.

### Analysis Tooling

`pitlab` CLI (Go): `summary` (dataset overview), `survival` (persona win rates), `position` (first-mover bias), `engagement` (reaction curves), `codebook` (research codebook generation). Operates on exported JSON.

---

## 6. Credit Economy

### How Billing Works

Credits are the unit of account. 1 credit = 100 micro-credits (bigint storage avoids floating-point). Gated by `CREDITS_ENABLED`.

**Cost estimation:** Before a bout runs, `estimateBoutCostGbp()` calculates expected cost based on model, turn count, and response length. The estimate is shown to the user.

**Preauthorisation:** Atomic conditional SQL: `UPDATE credits SET balance_micro = balance_micro - ? WHERE user_id = ? AND balance_micro >= ?`. If the balance is insufficient, the bout does not start. No race condition possible — the check and decrement are a single atomic operation.

**Settlement:** After the bout completes, actual token usage is computed (`computeCostGbp()`, `computeCostUsd()`). The difference between preauth and actual is refunded via `settleCredits()`. All transactions logged to `credit_transactions` (append-only ledger).

### Credit Sources

| Source | Amount |
|--------|--------|
| Signup | 100 credits |
| Community pool | 10,000 credits, 3-day half-life, shared by all anonymous users |
| Pit Pass subscription | +300 one-time, 300/month |
| Pit Lab subscription | +600 one-time, 600/month |
| Credit packs | Stripe one-time purchase |

### BYOK

Subscribers can paste their own Anthropic API key for unlimited bouts. Key is stashed in a short-lived HTTP-only cookie via `/api/byok-stash`, sent directly to Anthropic over HTTPS, never stored or logged. Gated by `BYOK_ENABLED`.

### Token Ceilings

| Length | Max output tokens | Per-turn tokens |
|--------|------------------|-----------------|
| Short | 266 | 160 |
| Standard | 300 | (default) |
| Long | 450 | (default) |

---

## 7. What's Working

Deployed, tested, functional at thepit.cloud:

- **Bout streaming** — round-robin multi-agent debate with SSE, 22 presets, custom lineups.
- **Agent creation and cloning** — structured DNA builder, lineage tracking, SHA-256 hashing.
- **Credit economy** — preauth/settlement, community pool, signup credits, Stripe subscriptions and credit packs.
- **BYOK** — user-supplied Anthropic keys, encrypted in transit, never stored.
- **Reactions and voting** — per-turn heart/fire reactions, winner votes, deduplicated.
- **Auth** — Clerk with tier-based access control (free/pass/lab).
- **Research page** — six hypotheses, literature review with 18 citations, dataset export pipeline.
- **Leaderboard** — agent win rates, vote counts, filterable by time window and source.
- **Recent bouts feed** — paginated, with reaction counts.
- **Share system** — auto-generated share lines, short links with click analytics.
- **Refusal detection** — pattern-based detection of model breaking character, logged for research.
- **Privacy** — GDPR cookie consent, IP anonymization (salted hash), research data anonymization.
- **Observability** — Sentry error tracking, PostHog analytics (consent-gated), LLM cost tracking, structured logging with key sanitization, anomaly detection.
- **Feature flags** — 11 env-gated booleans controlling all optional features.
- **Go CLI toolchain** — 8 tools (pitctl, pitforge, pitlab, pitnet, pitbench, pitstorm, pitlinear, shared library). Internal use, functional.
- **Test suite** — 1,125 Vitest tests passing, 7 Playwright E2E specs. CI via GitHub Actions.
- **Rate limiting** — per-IP, per-user, tier-differentiated. In-memory (per serverless instance).

---

## 8. What's Not Working / Known Gaps

- **Bout engine has zero direct tests.** `lib/bout-engine.ts` (1,221 lines) is the core execution path. It is exercised only through the API route in production. No unit or integration tests exist for `validateBoutRequest()` or `executeBout()`.
- **DB layer is 99% mocked in tests.** SQL correctness (joins, conditions, migrations) is not verified by the test suite. The `GREATEST(0,...)` safety net in credit operations has never been exercised in a test.
- **Known race condition untested.** Concurrent reactions on the same turn/bout have a documented race condition that is mitigated by a unique index but never tested under concurrent load.
- **EAS attestations not on-chain.** The entire attestation pipeline is built but the feature flag is off and no attestations have been submitted. See Section 4.
- **In-memory rate limiter does not share state across Vercel instances.** A distributed attacker could bypass per-instance limits. Mitigated by DB-level credit preauth (no credits = no bout). Assessed below 0.50 risk confidence by independent reviewers (SD-101).
- **Email delivery not configured.** Newsletter signups and contact form submissions are captured to DB but email sending (Resend) is not wired for transactional delivery.
- **Research export pipeline incomplete.** The endpoint exists; structured export formatting and public dataset hosting are not live.
- **38 React components have zero rendering tests.**
- **Credit history UI hidden.** The feature exists but was hidden pending UX review (SD-063).
- **No property-based, fuzz, or mutation testing.**

---

## 9. Agent Identity and Ethereum L2

### The Design

Every agent in The Pit has a deterministic cryptographic identity:

```
Agent DNA fields → SHA-256(systemPrompt) = promptHash
                 → SHA-256(all fields)   = manifestHash
```

These hashes are computed at agent creation and are immutable. They prove what instructions the agent was given — not what the agent will do.

The on-chain pipeline as designed:

```
Agent created in PostgreSQL
  → promptHash + manifestHash computed
  → EAS attestation encoded (SchemaEncoder)
  → Submitted to Base L2 via ethers
  → Returns attestation UID + tx hash
  → Stored in agents table
  → Verifiable via pitnet CLI or EAS explorer
```

### What This Proves

- **Tamper detection.** If an agent's prompt is modified after creation, the hash won't match the attestation. Like a signed git commit — it proves authorship and timestamp, not correctness.
- **Lineage.** Parent-child relationships are part of the attested schema. Clone chains are independently verifiable.
- **Public registry.** Any third party can verify an agent's identity against the on-chain record without trusting the platform.

### What This Does Not Prove

- **Behavioral trust.** The attestation says nothing about what the agent will actually say or do at runtime. The model provider controls inference. The prompt is an input, not a contract.
- **Model fidelity.** There is no mechanism to verify that the model provider executed the exact prompt as attested. If Anthropic silently changes system prompt handling, the attestation is still valid but the behavior may differ.
- **Runtime integrity.** The gap between "what the agent was told" and "what the agent did" is not bridged by hashing alone. Transcript hashing (built, not deployed) is a step toward this but does not close it.

### Current State

The code is written. The contracts exist on Base L2. The feature flag is off. No attestations have been submitted. The honest assessment: this is a working prototype of agent identity registration, not a deployed trust layer.

The aesthetic connection to Ethereum L2 is intentional: Base is low-cost, high-throughput, and aligned with the "signed commit" framing. EAS is a general-purpose attestation protocol that doesn't require deploying a custom contract. The design choice was pragmatic — use existing infrastructure for a specific, defensible claim (identity registration), not a grand claim (behavioral trust).
