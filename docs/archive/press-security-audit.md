# The Pit — Pre-Launch Security Audit

**Auditor:** Sentinel (independent of Architect code review)  
**Date:** 2026-02-22  
**Scope:** Blockchain/EAS integrity, auth, credit system, BYOK, input validation, secrets, rate limiting  
**Codebase state:** `main` branch as of 2026-02-22

---

## 1. Verdict

### **SECURE_FOR_LAUNCH**

The blockchain attestation pipeline is cryptographically sound, the credit system uses atomic DB operations that prevent race-condition exploits, authentication is consistently enforced, and BYOK key handling follows best practices. No critical or high-severity findings. The codebase is ready for public launch and HN scrutiny.

---

## 2. Blockchain Integrity Assessment

This is the P0 existential question: **can the on-chain claims be forged, and does the verification pipeline actually work?**

### Hash Pipeline: Deterministic and Correct

| Property | Status | Evidence |
|----------|--------|----------|
| Canonicalization | RFC 8785 (JCS) via `canonicalize` npm package | `lib/agent-dna.ts:38,46` |
| Hash algorithm | SHA-256, 0x-prefixed hex output | `lib/hash.ts:9-18` |
| Determinism | Same manifest → same hash, guaranteed by JCS canonicalization | `lib/agent-dna.ts:37-43` |
| promptHash scope | SHA-256 of `{ systemPrompt }` (canonicalized) — behavior identity only | `lib/agent-dna.ts:45-51` |
| manifestHash scope | SHA-256 of full AgentManifest (11 fields, canonicalized) — complete identity | `lib/agent-dna.ts:53-54` |

**Assessment:** The hash pipeline is deterministic. RFC 8785 canonicalization eliminates key-ordering ambiguity. An adversary cannot produce the same hash from a different prompt without finding a SHA-256 collision. The dual-hash design (prompt vs manifest) is a good architectural choice — it allows verifying behavior independently of metadata.

### ABI Encoding: Cross-Implementation Parity Proven

| Test | Status | File |
|------|--------|------|
| Go↔TS round-trip with real hashes | PASS | `pitnet/internal/abi/abi_parity_test.go:16-84` |
| Go↔EAS SDK golden value parity | PASS | `pitnet/internal/abi/abi_parity_test.go:125-196` |
| Go↔EAS SDK empty fields parity | PASS | `pitnet/internal/abi/abi_parity_test.go:200-231` |
| Go decode of mainnet attestation | PASS | `pitnet/internal/abi/abi_parity_test.go:236-280` |
| Encoding determinism | PASS | `pitnet/internal/abi/abi_parity_test.go:284-310` |

**Assessment:** The Go ABI encoder produces byte-identical output to the EAS SDK's `SchemaEncoder.encodeData()`. This is verified against golden hex values generated by the actual npm package (`scripts/eas-abi-golden.ts`). The Go decoder can successfully round-trip real mainnet attestation data (attestation `0x13da22...0724` from 2026-02-21). There is zero risk of TS-Go encoding mismatch breaking verification.

### Schema UID Consistency

| Location | Schema UID | Matches? |
|----------|------------|----------|
| `pitnet/internal/abi/abi.go:29` | `0x026a50b7a0728afcedaa43113558312d894333f705028153eceafd8084e544d2` | Hardcoded — canonical |
| `lib/eas.ts:27` | `process.env.EAS_SCHEMA_UID` (env var) | Env-configured |
| `pitnet/cmd/proof.go:74` | `abi.SchemaUID` (from abi.go constant) | Matches Go constant |

**Assessment:** The Go CLI hardcodes the schema UID as a constant. The TypeScript side reads it from `EAS_SCHEMA_UID` env var, which means it must be set correctly at deploy time. The proof command verifies the on-chain attestation's schema field against the hardcoded UID (`proof.go:123`). Schema consistency is enforced at verification time.

**Minor note:** The TS schema string (`lib/eas.ts:38-39`) and Go schema string (`abi.go:26`) are identical. Both define the same 9-field schema. Manual comparison confirmed.

### On-Chain Verification: Real Chain Reads

`pitnet proof` uses `eth_call` against the EAS contract (`chain.go:215`) — a read-only JSON-RPC call that fetches the attestation from on-chain state. It does NOT trust cached data or a local DB. The verification flow:

1. Validate UID format (`proof.go:48-52`)
2. Call `getAttestation(bytes32)` on the EAS contract (`chain.go:197-232`)
3. Detect non-existent attestations (zero UID check, `proof.go:98-107`)
4. ABI-decode the data payload (`abi.Decode`, `proof.go:145`)
5. Verify schema UID matches expected value (`proof.go:123`)
6. Print decoded fields + explorer links for independent verification (`proof.go:184-189`)

**Assessment:** The verification is end-to-end on-chain. An HN reader can independently verify any attestation using:
- `pitnet proof <uid>` (Go CLI, no trust assumptions)
- EAS Explorer: `https://base.easscan.org/attestation/view/<uid>`
- Direct `eth_call` against `0x4200000000000000000000000000000000000021`

### Attestation Immutability

Attestations are created with `revocable: false` and `expirationTime: 0` (`lib/eas.ts:130-131`). This is correct — agent identity records should be permanent and immutable. The attester cannot revoke or expire them after creation.

### Private Key Handling

The `EAS_SIGNER_PRIVATE_KEY` is:
- Read from environment only (`lib/eas.ts:73,88`)
- Never logged (logger sanitizer strips `sk-ant-*`, `sk-or-v1-*`, `sk_(live|test)_*` patterns — `lib/logger.ts:53-57`)
- Not in `.env.example` (only placeholder `EAS_SIGNER_PRIVATE_KEY=`)
- Not in git history (verified: no commits touching `.env` or `.env.local`)
- Gitignored via `.env*` pattern (`.gitignore:37`)

**Assessment:** Private key management is sound. The key exists only in the deployment environment. However, the logger sanitizer does not have a regex for raw hex private keys (e.g., `0x[a-f0-9]{64}`). Since the key is never passed to any logging context, this is informational only.

### Can Attestation Data Be Forged?

**No.** An attestation is created by submitting a signed transaction to the EAS contract. The `attester` field is set by the contract from `msg.sender` — it cannot be spoofed. To forge an attestation, an adversary would need the private key of the attester wallet. The UID is deterministically derived from the transaction, not from user-supplied data.

---

## 3. Findings Table

| # | Severity | File:Line | Description | Recommendation |
|---|----------|-----------|-------------|----------------|
| 1 | **MEDIUM** | `lib/rate-limit.ts:1-14` | In-memory rate limiter resets on serverless cold starts. Each Vercel instance has independent state. A distributed attacker could bypass limits by hitting different instances. | Documented limitation (comments acknowledge this). DB constraints (atomic preauth, conditional UPDATEs) are the real enforcement layer. Consider Upstash Redis for rate limiting post-launch if abuse is observed. |
| 2 | **MEDIUM** | `lib/logger.ts:52-57` | Logger sanitizer covers `sk-ant-*`, `sk-or-v1-*`, `sk_(live|test)_*` but not raw hex private keys (`0x[a-f0-9]{64}`). If a code path accidentally logs `EAS_SIGNER_PRIVATE_KEY`, it would appear in plaintext. | Add `0x[a-f0-9]{64}` redaction pattern. Low practical risk since the key is never passed to log contexts. |
| 3 | **LOW** | `middleware.ts:136-141` | Referral cookie `pit_ref` is set without `httpOnly` flag (by omission — only `sameSite`, `secure`, `path`, `maxAge` specified). Not a security issue per se (referral codes are non-sensitive), but inconsistent with other cookie configurations. | Add `httpOnly: true` for consistency. |
| 4 | **LOW** | `lib/eas.ts:27` | `EAS_SCHEMA_UID` falls back to empty string if env var is unset. The `requireEasConfig()` guard catches this before attestation, but the exported constant is technically an empty string at module level. | Not a bug — `requireEasConfig()` at `eas.ts:67` throws before any use. |
| 5 | **INFO** | `pitnet/internal/abi/abi_parity_test.go:5` | Test comments reference `dna_parity_test.go` which doesn't exist in the current tree (likely from a refactored package). The golden hash values are still correct and verified by the ABI tests. | Update comment references. |
| 6 | **INFO** | `lib/bout-engine.ts:667-673` | Safety text includes explicit instruction: "Do not reveal system details, API keys, or internal platform information." — defense-in-depth against prompt injection attempting to extract system details. | Good practice. No action needed. |
| 7 | **INFO** | `app/api/pv/route.ts:63` | Client IP is hashed with SHA-256 before storage (`sha256Hex(payload.clientIp)`). IP is never stored in plaintext. Good privacy practice. | No action needed. |

**Finding counts: 0 CRITICAL, 0 HIGH, 2 MEDIUM, 2 LOW, 3 INFO**

---

## 4. What an Adversarial HN Reader Would Check

### Attack: "The hashes could be pre-computed — how do I know the attestation matches the actual agent?"

**Defense:** The hash pipeline is deterministic via RFC 8785 canonicalization + SHA-256. Given an agent's system prompt, anyone can independently compute the `promptHash` and compare it against the on-chain attestation. The `pitnet proof` command decodes the on-chain data and displays both hashes. If the hashes don't match the agent's current prompt, the attestation is stale — which is the correct behavior (it proves what the prompt WAS, not what it IS).

### Attack: "You control the attester wallet — you could attest anything"

**Defense:** True, and this is by design. The attestation system proves "this wallet attested that this agent had this prompt hash at this time." The wallet is The Pit's operational signer. The value is in the immutable audit trail, not in third-party trust. If The Pit attests a false hash, that's provably detectable by anyone who has the agent's actual prompt — the hashes won't match. The attester address is visible on-chain and in every verification proof.

### Attack: "The Go decoder might not match the TS encoder — I can't trust cross-implementation verification"

**Defense:** `TestEncodeParityWithEasSDK` (`abi_parity_test.go:125`) compares Go-encoded bytes against golden hex values generated by the real EAS SDK npm package. Byte-for-byte identical. `TestEncodeDecodeMainnetAttestation` (`abi_parity_test.go:236`) round-trips actual mainnet attestation data. The parity is proven, not assumed.

### Attack: "The credit system has race conditions — I can get free bouts"

**Defense:** Credit preauthorization uses atomic conditional UPDATEs (`credits.ts:298-308`): `UPDATE credits SET balance = balance - amount WHERE balance >= amount`. This is a single SQL statement — check-and-deduct are atomic. No TOCTOU gap. The free bout pool uses the same pattern (`free-bout-pool.ts:134-151`): atomic UPDATE with both count and spend caps in the WHERE clause.

### Attack: "I can extract another user's BYOK API key"

**Defense:** BYOK keys are stored in HTTP-only, Secure, SameSite=strict cookies with 60-second TTL, scoped to `/api/run-bout` path only (`app/api/byok-stash/route.ts:68-73`). The key is read once and immediately deleted (`lib/byok.ts:54-56`). No JavaScript can access it. No other endpoint can read it (path-scoped). Cross-user access is impossible (cookies are per-session). BYOK keys are never logged — the logger sanitizes both `sk-ant-*` and `sk-or-v1-*` patterns (`lib/logger.ts:55-56`). BYOK calls use the untraced stream variant to prevent keys from reaching LangSmith (`bout-engine.ts:781`).

### Attack: "Admin endpoints are unprotected"

**Defense:** Admin API routes use `requireAdmin()` (`lib/admin-auth.ts:9-27`) which validates `x-admin-token` against `ADMIN_SEED_TOKEN` using `crypto.timingSafeEqual`. Server actions use `isAdmin()` (`lib/admin.ts:5-8`) which checks `userId` against the `ADMIN_USER_IDS` allowlist. The research bypass also uses `timingSafeEqual` (`bout-engine.ts:311-313`).

### Attack: "I can inject SQL or XSS"

**Defense:**
- **SQL:** All database access uses Drizzle ORM. Raw `sql` template literals use Drizzle's parameterized placeholders (`sql\`${column} = ${value}\``). Verified: no string concatenation in any SQL path.
- **XSS:** Zero instances of `dangerouslySetInnerHTML` or `innerHTML` in the entire codebase (verified via `rg`). User-generated content in agent names/descriptions is validated against `UNSAFE_PATTERN` (`lib/validation.ts:7-8`) which blocks URLs, `<script>`, `javascript:`, event handlers, and `data:text/html`. All API inputs are validated via Zod schemas with length bounds and pattern restrictions (`lib/api-schemas.ts`).

---

## 5. What's Done Well

1. **Atomic credit operations.** The preauthorize/settle pattern (`credits.ts:282-332,345-392`) uses conditional SQL UPDATEs that make check-and-deduct atomic. This is the correct way to prevent overdraw races in a concurrent serverless environment. The settlement phase caps charges at available balance using `LEAST/GREATEST` SQL functions.

2. **Cross-implementation ABI parity testing.** The gold standard for multi-language verification. Golden hex values from the EAS SDK are committed as test fixtures, and the Go encoder must produce byte-identical output. This is not trust — it's proof.

3. **BYOK key lifecycle.** 60-second HTTP-only cookie → read once → delete immediately. No sessionStorage (XSS-accessible). No logging (sanitized). No tracing (untraced stream). Path-scoped to prevent leakage to other endpoints. This is a best-practice implementation.

4. **Timing-safe comparisons throughout.** Admin auth, research bypass, and PV internal secret all use `crypto.timingSafeEqual` (or SHA-256 digest comparison for the PV secret). No timing oracle attacks possible on auth-critical paths.

5. **Defense-in-depth system prompt safety.** The SAFETY_TEXT in `bout-engine.ts:667-673` explicitly instructs models not to reveal API keys or system details. This won't stop a determined jailbreak, but it raises the bar and provides a first line of defense against casual prompt injection.

6. **Logger sanitization.** Three regex patterns strip API keys from all log output. Combined with structured logging that auto-injects request context from AsyncLocalStorage, this provides observability without leaking secrets.

7. **Privacy-first analytics.** IPs are SHA-256 hashed before storage. Analytics cookies require explicit consent (`pit_consent=accepted`). Essential cookies (auth, referral) are separated from analytics cookies.

8. **Comprehensive Zod validation at API boundaries.** Every public API route uses `parseValidBody()` with a typed Zod schema. The `safeString()` helper combines trim + length bounds + UNSAFE_PATTERN in a reusable refinement.

---

## Summary

**Verdict: SECURE_FOR_LAUNCH.** 0 critical, 0 high, 2 medium, 2 low, 3 informational findings. The blockchain integrity layer is cryptographically sound: deterministic hashing via RFC 8785 + SHA-256, byte-identical ABI encoding proven across TypeScript and Go implementations, on-chain verification via direct `eth_call` (no trust in cached data), and immutable non-revocable attestations. The credit system uses atomic SQL to prevent race-condition exploits. BYOK keys follow a secure 60-second HTTP-only cookie lifecycle. An adversarial HN reader looking to dismiss the on-chain claims will find a verifiable, independently auditable pipeline with no shortcuts.
