#!/usr/bin/env bash
# concat-docs.sh — Crawl the Documentation Index from README.md and
# concatenate all referenced markdown files into a single output file
# suitable for feeding to an LLM for architectural diagram generation.
#
# Usage:
#   ./scripts/concat-docs.sh              # writes to docs/architecture-bundle.md
#   ./scripts/concat-docs.sh output.md    # writes to custom path

set -euo pipefail

REPO_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
OUTPUT="${1:-$REPO_ROOT/docs/architecture-bundle.md}"

# ── Documentation Index (order matches README.md § Documentation Index) ──────
DOC_FILES=(
  "app/README.md"
  "app/api/README.md"
  "components/README.md"
  "lib/README.md"
  "db/README.md"
  "presets/README.md"
  "tests/README.md"
  "scripts/README.md"
  "drizzle/README.md"
  "docs/README.md"
  "pitctl/README.md"
  "pitforge/README.md"
  "pitbench/README.md"
  "pitlab/README.md"
  "pitnet/README.md"
  "pitlinear/README.md"
  "pitstorm/README.md"
  "shared/README.md"
  # Root documents
  "ARCHITECTURE.md"
  "ROADMAP.md"
  "AGENTS.md"
)

# Helper: create a slug from a file path for use as an HTML anchor
make_anchor() {
  local path="$1"
  # lowercase, replace non-alphanumeric with hyphens, collapse runs, trim
  printf '%s' "$path" \
    | tr 'A-Z' 'a-z' \
    | sed 's/[^a-z0-9]/-/g; s/--*/-/g; s/^-//; s/-$//'
}

# ── Build output ─────────────────────────────────────────────────────────────

included=0
skipped=0
skipped_list=()

{
  cat <<'HEADER'
# The Pit -- Documentation Bundle

HEADER
  printf '> Auto-generated by `scripts/concat-docs.sh` on %s.\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  printf '> Feed this file to an LLM to generate architectural diagrams.\n\n'
  printf '## Table of Contents\n\n'

  # TOC pass
  toc_index=1
  for file in "${DOC_FILES[@]}"; do
    filepath="$REPO_ROOT/$file"
    if [[ -f "$filepath" ]]; then
      title=$(grep -m1 '^# ' "$filepath" | sed 's/^# //' || true)
      if [[ -z "$title" ]]; then
        title="$file"
      fi
      anchor=$(make_anchor "$file")
      printf '%d. [%s](#source-%s) -- `%s`\n' "$toc_index" "$title" "$anchor" "$file"
      toc_index=$((toc_index + 1))
    fi
  done

  printf '\n---\n\n'

  # Content pass
  for file in "${DOC_FILES[@]}"; do
    filepath="$REPO_ROOT/$file"
    if [[ ! -f "$filepath" ]]; then
      skipped=$((skipped + 1))
      skipped_list+=("$file")
      continue
    fi

    anchor=$(make_anchor "$file")
    printf '<a id="source-%s"></a>\n\n' "$anchor"
    printf '## Source: `%s`\n\n' "$file"
    cat "$filepath"
    printf '\n\n---\n\n'
    included=$((included + 1))
  done

  # Summary footer
  printf '## Bundle Summary\n\n'
  printf 'Files included: %d\n' "$included"
  printf 'Files skipped (not found): %d\n' "$skipped"
  if [[ ${#skipped_list[@]} -gt 0 ]]; then
    printf 'Skipped:\n'
    for f in "${skipped_list[@]}"; do
      printf '  %s\n' "$f"
    done
  fi
  printf 'Generated: %s\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)"

} > "$OUTPUT"

# ── Report ───────────────────────────────────────────────────────────────────

line_count=$(wc -l < "$OUTPUT")
byte_count=$(wc -c < "$OUTPUT")
kb=$((byte_count / 1024))

printf 'concat-docs: %d files included, %d skipped\n' "$included" "$skipped"
printf 'concat-docs: wrote %s (%d lines, %d KB)\n' "$OUTPUT" "$line_count" "$kb"

if [[ ${#skipped_list[@]} -gt 0 ]]; then
  printf 'concat-docs: skipped files:\n'
  for f in "${skipped_list[@]}"; do
    printf '  %s\n' "$f"
  done
fi
