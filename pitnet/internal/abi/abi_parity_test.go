// Cross-implementation parity tests for ABI encoding.
//
// These tests verify that the ABI encoder works correctly with
// real hash values produced by the dna package (which are verified
// against the TypeScript implementation in dna_parity_test.go).
// This creates a complete chain: TS hashes -> Go hashes -> ABI encoding.
package abi

import (
	"encoding/hex"
	"testing"
)

// TestEncodeDecodeWithRealHashes verifies the full pipeline using
// actual hash values that are verified to match the TS implementation.
func TestEncodeDecodeWithRealHashes(t *testing.T) {
	// These hashes are golden values from dna_parity_test.go,
	// verified to be byte-identical with lib/agent-dna.ts output.
	data := AttestationData{
		AgentID:      "agent-3",
		Name:         "Hashy",
		PresetID:     "",
		Tier:         "custom",
		PromptHash:   "0xf2d7077205ae5669ec1d82dcaacd45b2480d272bbb3443049899b31fdba6fd80",
		ManifestHash: "0xaefa987e8e894a687d9ee3f836442241ed11f37cb2547ec16145d7aefc102e6d",
		ParentID:     "",
		OwnerID:      "",
		CreatedAt:    1738972800, // 2026-02-08T00:00:00Z as unix
	}

	encoded, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode: %v", err)
	}

	// Verify encoding is well-formed.
	if len(encoded)%32 != 0 {
		t.Errorf("encoded length %d is not a multiple of 32", len(encoded))
	}

	// Guard: encoded must be at least 192 bytes to contain both hash slots.
	if len(encoded) < 192 {
		t.Fatalf("encoded length %d is too short (need at least 192 bytes for hash slots)", len(encoded))
	}

	// Verify the bytes32 fields are at the correct positions.
	promptHashSlot := encoded[128:160]
	manifestHashSlot := encoded[160:192]

	wantPrompt := "f2d7077205ae5669ec1d82dcaacd45b2480d272bbb3443049899b31fdba6fd80"
	wantManifest := "aefa987e8e894a687d9ee3f836442241ed11f37cb2547ec16145d7aefc102e6d"

	if hex.EncodeToString(promptHashSlot) != wantPrompt {
		t.Errorf("prompt hash slot = %s, want %s", hex.EncodeToString(promptHashSlot), wantPrompt)
	}
	if hex.EncodeToString(manifestHashSlot) != wantManifest {
		t.Errorf("manifest hash slot = %s, want %s", hex.EncodeToString(manifestHashSlot), wantManifest)
	}

	// Verify roundtrip.
	decoded, err := Decode(encoded)
	if err != nil {
		t.Fatalf("Decode: %v", err)
	}

	if decoded.AgentID != data.AgentID {
		t.Errorf("AgentID = %q, want %q", decoded.AgentID, data.AgentID)
	}
	if decoded.Name != data.Name {
		t.Errorf("Name = %q, want %q", decoded.Name, data.Name)
	}
	if decoded.Tier != data.Tier {
		t.Errorf("Tier = %q, want %q", decoded.Tier, data.Tier)
	}
	if decoded.PromptHash != data.PromptHash {
		t.Errorf("PromptHash = %q, want %q", decoded.PromptHash, data.PromptHash)
	}
	if decoded.ManifestHash != data.ManifestHash {
		t.Errorf("ManifestHash = %q, want %q", decoded.ManifestHash, data.ManifestHash)
	}
	if decoded.CreatedAt != data.CreatedAt {
		t.Errorf("CreatedAt = %d, want %d", decoded.CreatedAt, data.CreatedAt)
	}
}

// TestEncodeDecodeAgentOneHashes verifies with agent-1 golden values.
func TestEncodeDecodeAgentOneHashes(t *testing.T) {
	data := AttestationData{
		AgentID:      "agent-1",
		Name:         "Test Agent",
		PresetID:     "",
		Tier:         "free",
		PromptHash:   "0x82d87bd74898f678397803acffe9f572ce39b28273d8e41dc8aa9d00eb7a4767",
		ManifestHash: "0x3a646626e32aa6ac52d431ad52131f915dd7087f06d7da5909e79d5e55443849",
		ParentID:     "",
		OwnerID:      "",
		CreatedAt:    1738972800,
	}

	encoded, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode: %v", err)
	}

	decoded, err := Decode(encoded)
	if err != nil {
		t.Fatalf("Decode: %v", err)
	}

	if decoded.PromptHash != data.PromptHash {
		t.Errorf("PromptHash roundtrip failed: got %s, want %s", decoded.PromptHash, data.PromptHash)
	}
	if decoded.ManifestHash != data.ManifestHash {
		t.Errorf("ManifestHash roundtrip failed: got %s, want %s", decoded.ManifestHash, data.ManifestHash)
	}
}

// TestEncodeParityWithEasSDK verifies that Go's ABI encoder produces
// byte-identical output to the EAS SDK's SchemaEncoder.encodeData().
//
// The golden hex values were generated by scripts/eas-abi-golden.ts using
// the real @ethereum-attestation-service/eas-sdk npm package. If this test
// fails, the Go and TS implementations have diverged â€” attestations written
// by TS will not decode correctly in Go (or vice versa).
func TestEncodeParityWithEasSDK(t *testing.T) {
	data := AttestationData{
		AgentID:      "agent-golden-001",
		Name:         "Golden Agent",
		PresetID:     "preset-alpha",
		Tier:         "premium",
		PromptHash:   "0x" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab" + "ab",
		ManifestHash: "0x" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd" + "cd",
		ParentID:     "parent-000",
		OwnerID:      "user_golden123",
		CreatedAt:    1700000000,
	}

	encoded, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode: %v", err)
	}

	// Golden value from scripts/eas-abi-golden.ts (EAS SDK SchemaEncoder)
	goldenHex := "0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e0ababababababababababababababababababababababababababababababababcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd00000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000260000000000000000000000000000000000000000000000000000000006553f10000000000000000000000000000000000000000000000000000000000000000106167656e742d676f6c64656e2d30303100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c476f6c64656e204167656e740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c7072657365742d616c706861000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000077072656d69756d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a706172656e742d30303000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e757365725f676f6c64656e313233000000000000000000000000000000000000"

	goHex := hex.EncodeToString(encoded)
	if goHex != goldenHex {
		t.Errorf("Go ABI encoding does not match EAS SDK output\n  Go  len=%d\n  EAS len=%d", len(goHex), len(goldenHex))
		// Find first difference
		for i := 0; i < len(goHex) && i < len(goldenHex); i++ {
			if goHex[i] != goldenHex[i] {
				t.Errorf("  first difference at hex position %d (byte %d)", i, i/2)
				t.Errorf("  Go:  ...%s...", goHex[max(0, i-16):min(len(goHex), i+16)])
				t.Errorf("  EAS: ...%s...", goldenHex[max(0, i-16):min(len(goldenHex), i+16)])
				break
			}
		}
	}

	// Also verify the Go decoder can round-trip the EAS SDK output
	easBytes, err := hex.DecodeString(goldenHex)
	if err != nil {
		t.Fatalf("decode golden hex: %v", err)
	}
	decoded, err := Decode(easBytes)
	if err != nil {
		t.Fatalf("Decode EAS SDK bytes: %v", err)
	}
	if decoded.AgentID != data.AgentID {
		t.Errorf("AgentID = %q, want %q", decoded.AgentID, data.AgentID)
	}
	if decoded.Name != data.Name {
		t.Errorf("Name = %q, want %q", decoded.Name, data.Name)
	}
	if decoded.PresetID != data.PresetID {
		t.Errorf("PresetID = %q, want %q", decoded.PresetID, data.PresetID)
	}
	if decoded.Tier != data.Tier {
		t.Errorf("Tier = %q, want %q", decoded.Tier, data.Tier)
	}
	if decoded.PromptHash != data.PromptHash {
		t.Errorf("PromptHash = %q, want %q", decoded.PromptHash, data.PromptHash)
	}
	if decoded.ManifestHash != data.ManifestHash {
		t.Errorf("ManifestHash = %q, want %q", decoded.ManifestHash, data.ManifestHash)
	}
	if decoded.ParentID != data.ParentID {
		t.Errorf("ParentID = %q, want %q", decoded.ParentID, data.ParentID)
	}
	if decoded.OwnerID != data.OwnerID {
		t.Errorf("OwnerID = %q, want %q", decoded.OwnerID, data.OwnerID)
	}
	if decoded.CreatedAt != data.CreatedAt {
		t.Errorf("CreatedAt = %d, want %d", decoded.CreatedAt, data.CreatedAt)
	}
}

// TestEncodeParityEmptyFields verifies parity with the EAS SDK when optional
// string fields are empty.
func TestEncodeParityEmptyFields(t *testing.T) {
	data := AttestationData{
		AgentID:      "agent-empty-002",
		Name:         "Empty Agent",
		PresetID:     "",
		Tier:         "free",
		PromptHash:   "0x0000000000000000000000000000000000000000000000000000000000000000",
		ManifestHash: "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		ParentID:     "",
		OwnerID:      "",
		CreatedAt:    0,
	}

	encoded, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode: %v", err)
	}

	// Golden value from scripts/eas-abi-golden.ts (EAS SDK SchemaEncoder)
	goldenHex := "0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f6167656e742d656d7074792d3030320000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b456d707479204167656e7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004667265650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"

	goHex := hex.EncodeToString(encoded)
	if goHex != goldenHex {
		t.Errorf("Go ABI encoding (empty fields) does not match EAS SDK output\n  Go  len=%d\n  EAS len=%d", len(goHex), len(goldenHex))
		for i := 0; i < len(goHex) && i < len(goldenHex); i++ {
			if goHex[i] != goldenHex[i] {
				t.Errorf("  first difference at hex position %d (byte %d)", i, i/2)
				break
			}
		}
	}
}

// TestEncodeDecodeMainnetAttestation verifies that the Go decoder can
// successfully decode a real attestation fetched from Base mainnet.
// This is the ultimate proof: TS wrote it on-chain, Go reads it back.
func TestEncodeDecodeMainnetAttestation(t *testing.T) {
	// Attestation 0x13da22...0724 on Base mainnet, decoded by pitnet verify.
	// These values were read live from the chain on 2026-02-21.
	data := AttestationData{
		AgentID:      "30UcKDKpxz6CB-R6Amc_X",
		Name:         "StormAgent-3581",
		PresetID:     "",
		Tier:         "custom",
		PromptHash:   "0x0d5a7a1fa37f8a7b137cad56b6a2d2821bb1acb3ac82f8060cc1e3c64abe285f",
		ManifestHash: "0xd43dd144d3a79ac6196d3a3d9b615d4b6bdb56823d37e6e3a95054a842fa4ad9",
		ParentID:     "",
		OwnerID:      "user_39lbw5JOLRVRBHRPmjuoBi66OQQ",
		CreatedAt:    1771354081,
	}

	// Encode with Go, decode back, verify round-trip
	encoded, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode: %v", err)
	}

	decoded, err := Decode(encoded)
	if err != nil {
		t.Fatalf("Decode: %v", err)
	}

	if decoded.AgentID != data.AgentID {
		t.Errorf("AgentID = %q, want %q", decoded.AgentID, data.AgentID)
	}
	if decoded.Name != data.Name {
		t.Errorf("Name = %q, want %q", decoded.Name, data.Name)
	}
	if decoded.PromptHash != data.PromptHash {
		t.Errorf("PromptHash = %q, want %q", decoded.PromptHash, data.PromptHash)
	}
	if decoded.ManifestHash != data.ManifestHash {
		t.Errorf("ManifestHash = %q, want %q", decoded.ManifestHash, data.ManifestHash)
	}
	if decoded.OwnerID != data.OwnerID {
		t.Errorf("OwnerID = %q, want %q", decoded.OwnerID, data.OwnerID)
	}
	if decoded.CreatedAt != data.CreatedAt {
		t.Errorf("CreatedAt = %d, want %d", decoded.CreatedAt, data.CreatedAt)
	}
}

// TestEncodeDeterministic verifies that encoding the same data twice
// produces byte-identical output.
func TestEncodeDeterministic(t *testing.T) {
	data := AttestationData{
		AgentID:      "agent-deterministic",
		Name:         "Determinism Test",
		PresetID:     "preset-1",
		Tier:         "premium",
		PromptHash:   "0xf2d7077205ae5669ec1d82dcaacd45b2480d272bbb3443049899b31fdba6fd80",
		ManifestHash: "0xaefa987e8e894a687d9ee3f836442241ed11f37cb2547ec16145d7aefc102e6d",
		ParentID:     "parent-1",
		OwnerID:      "owner-1",
		CreatedAt:    1738972800,
	}

	enc1, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode 1: %v", err)
	}

	enc2, err := Encode(data)
	if err != nil {
		t.Fatalf("Encode 2: %v", err)
	}

	if hex.EncodeToString(enc1) != hex.EncodeToString(enc2) {
		t.Error("encoding is not deterministic: two identical inputs produced different output")
	}
}
